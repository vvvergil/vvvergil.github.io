---
title: 前端算法题
date: 2022-12-21 10:03:23
updated: 2024-05-05 09:11:10
categories: 算法
tags: [算法]

---

# 前端算法题

## 前言

既然要写一个前端技术博客，一些前端的算法题当然要记录下来。这里的题很多都是我在面试过程中遇到过的，也有一些是四处收集来的，相较与leetcode上的代码题。这里的算法题更加注重前端方向，也是对前端er代码能力的重要考验。当然题目的解法大部分还是自己想的，也有小部分收集到的，如果有哪里不对，还请大家帮忙指正。

## 实现Promise.all

**描述**：请自己实现一个Promise.all函数

**分析**：Promise.all函数：`const p=Promise.all([p1,p2,p3])`，参数为一个Promise数组，若非数组会报错，返回值为Promise。当p1、p2、p3都落定到fulfilled状态时，p为fulfilled状态，参数为p1、p2、p3返回值组成的数组。当数组中有一个Promise（假设为p1）落定到rejected状态时，p为rejected状态，reason为p1的reason。

**实现**：

```javascript
//实现Promise.all

const myPromiseAll=(promises)=>{
  if(!(promises instanceof Array)){
    throw new Error('not array');
  }
  if(promises.length===0){
    return Promise.resolve([]);
  }

  const res=[];
  let length= promises.length;

  return new Promise((resolve,reject)=>{
    promises.forEach((p,i) => {
      Promise.resolve(p).then(v => {
        res[i]=v;
        length--;
        if(length===0){
          resolve(res);
        }
      }).catch(err => {
        reject(err);
      })
    })
  })

}

const genPromise = (v,flag,delay)=> {
  return new Promise((res,rej)=>{
    setTimeout(()=>{
      flag?res(v):rej(v);
    },delay)
  })
}

const testData=[genPromise(1,true,1000),genPromise(2,false,2000),genPromise(3,true,3000)];

myPromiseAll(testData)
.then(v=>console.log(v)).catch(err => console.log(err));

Promise.all(testData)
.then(v=>console.log(v)).catch(err => console.log(err));
```

## 实现Promise.allSettled

**描述**：请自己实现一个Promise.allSettled函数

**分析**：Promise.all函数：`const p=Promise.all([p1,p2,p3])`，参数为一个Promise数组，若非数组会报错，返回值为Promise。当p1、p2、p3都落定到fulfilled状态时，p为fulfilled状态，参数为p1、p2、p3返回值组成的数组。当数组中有一个Promise（假设为p1）落定到rejected状态时，p为rejected状态，reason为p1的reason。

**实现**：

```javascript
//实现Promise.allSettled

const myPromiseAllSettled=(promises)=>{
  if(!(promises instanceof Array)){
    throw new Error('not array');
  }
  if(promises.length===0){
    return Promise.resolve([]);
  }

  const res=[];
  let length= promises.length;

  return new Promise((resolve,reject)=>{
    promises.forEach((p,i) => {
      Promise.resolve(p).then(v => {
        res[i]={
          status:'fulfilled',
          value:v
        };

      }).catch(err => {
        res[i]={
          status:'rejected',
          reason:err
        }
      }).finally(()=>{
        length--;
        if(length===0){
          resolve(res);
        }
      })
    })
  })

}

const genPromise = (v,flag,delay)=> {
  return new Promise((res,rej)=>{
    setTimeout(()=>{
      flag?res(v):rej(v);
    },delay)
  })
}

const testData=[genPromise(1,true,1000),genPromise(2,false,2000),genPromise(3,true,3000)];

myPromiseAllSettled(testData)
.then(v=>console.log(v)).catch(err => console.log(err));

Promise.allSettled(testData)
.then(v=>console.log(v)).catch(err => console.log(err));
```

## 实现async函数

**描述**：请自己实现async函数，即使用同步的写法来书写异步函数。

**分析**：async函数最重要的特点是，在函数内部，遇到await关键字时会中断函数的执行，直到其后的异步函数返回结果，函数才能继续执行。考虑到中断函数执行，很自然可以想到Generator也可以中断函数执行，执行Generator函数会生成一个迭代器。通过调用迭代器的next函数可以手动恢复函数执行直到遇到下一个yield关键字。如果将yield关键字视作await关键字，那么还需要解决的问题有两个，1是需要在异步函数执行完毕后自动恢复函数执行，2是需要将异步函数返回的值保存下来以供后续代码的使用。

**实现**：

```javascript
// 实现async函数

function *genAsyncFunc(){
  const v1 = yield genPromise(1,true,1000);
  console.log(v1);

  const v2 = yield genPromise(2,true,1000);
  console.log(v1+v2);

  const v3 = yield genPromise(3,true,1000);
  console.log(v1+v2+v3);
}

//装饰器，模拟async关键字的作用
function asyncFunc(fn){
  let iter = fn();

  const addNext = ({value,done})=>{
    if(!done){
      Promise.resolve(value).then(v => {
        addNext(iter.next(v))
      }).catch(err => {throw err});
    }
  }

  addNext(iter.next());
}

const genPromise = (v,flag,delay)=> {
  return new Promise((res,rej)=>{
    setTimeout(()=>{
      flag?res(v):rej(v);
    },delay)
  })
}

asyncFunc(genAsyncFunc);
```

## 实现节流函数

**描述**：节流是为了避免某个函数被频繁的调用而采取的控制手段，一个函数使用节流封装后，可以实现在指定时间内，函数被调用若干次也只执行一次的效果。

**分析**：根据描述，可以知道节流函数的输入有两个，分别是被封装的函数，以及指定时间。返回一个使用节流封装后的函数。需要注意的点有，节流函数在第一次被调用时应该立即执行，指定时间内的第二次或更多次调用应当延时到指定时间之后执行。

**实现**：

```javascript
//节流
function throttle(fn,delay){
  let timer = null;
  let oldDate = Date.now();
  return function(){
    let curDate = Date.now();
    let remainTime = delay - (curDate - oldDate);
    let context = this;
    let arg = arguments;
    clearTimeout(timer);
    if(remainTime < 0){
      fn.apply(context,arg);
      oldDate = curDate;
    }else{
      timer = setTimeout(()=>fn.apply(context,arg),remainTime);
    }
  }
}

let printFn = throttle((v)=>console.log(v),1000);

setTimeout(()=>{
  printFn(1);
  printFn(2);
  printFn(3);
  //1
  //3
  //这里连续调用了printFn三次，1被立即输出，2和3都在延迟时间内所以2被忽略，而3被推迟到延迟时间之后执行。
},2000);

setTimeout(()=>printFn(4),4000);
```

## 实现防抖函数

**描述**：防抖也是为了避免某些函数被频繁调用而设计的，它的效果是函数被调用后，不立刻执行，而是等待delay秒后再执行，这期间如果被再次调用，那么以最后一次调用时间开始重新等待delay秒后执行。即一个函数被连续一连串的调用后，实际只执行一次，执行的时机是最后一次调用的时间+delay后的时刻。

**分析**：和节流一样，防抖函数的输入也有两个，一个是被封装的函数，另一个是延迟时间。返回一个使用防抖包装后的函数。

**实现**：

```javascript
//实现防抖函数
//简单的防抖函数，第一次调用时不立即执行
function denounce(fn,delay){
  let timer = null;
  return function(){
    const context = this;
    const arg = arguments;
    if(timer){
      clearTimeout(timer);
    }
    timer = setTimeout(()=>{
      fn.apply(context,arg);
      timer = null;
    },delay);
  }
}

//稍微复杂一点的防抖，第一次调用的时候立即执行，后续调用延迟执行
function denounce1(fn,delay,immediate){
  let timer = null;
  return function(){
    const context = this;
    const arg = arguments;
    if(timer){
      clearTimeout(timer);
    }
    if(immediate){
      //第一次调用的时候立即执行
      if(!timer){
        //timer内什么都不做，只是为了下一次函数调用时让函数知道已经不是第一次调用了
        timer = setTimeout(()=>timer = null,delay);  
        fn.apply(context,arg);
      }else{
        timer = setTimeout(()=>{
          fn.apply(context,arg);
          timer = null;
        },delay);
      }
    }else{
      timer = setTimeout(()=>{
        fn.apply(context,arg);
        timer = null;
      },delay);
    }
  }
}

let printValue = denounce((v)=>console.log(v),1000);
printValue(1);
printValue(2);
printValue(3);
//3
setTimeout(()=>{
  printValue = denounce1((v)=>console.log(v),1000,true);
  printValue(1);
  printValue(2);
  printValue(3);
  //1
  //3
},2000);
```

## 实现发布订阅模式

**描述**：请自己实现发布订阅模式。

**分析**：发布订阅模式，即用户可以订阅某个事件，并注册回调函数，当事件触发后，会调用所有注册的回调函数。

**实现**：

```javascript
//实现发布订阅模式
class Service {
  constructor(){
    this.eventMap = new Map();
  }

  subscribe(event,callback){
    if(this.eventMap.has(event)){
      this.eventMap.set(event,[...this.eventMap.get(event),callback]);
    }else{
      this.eventMap.set(event,[callback]);
    }
  }

  unSubscribe(event,callback){
    let index = this.eventMap.get(event).indexOf(callback);
    if(index>=0){
      this.eventMap.get(event).splice(index,1);
    }
  }

  emit(event,...arg){
    if(this.eventMap.has(event)){
      this.eventMap.get(event).forEach(cb => cb(...arg))
    }
  }
}

const service = new Service();

let print = () =>console.log(4)
service.subscribe('print',(...arg)=>console.log(...arg));
service.subscribe('print',()=>console.log(2));
service.subscribe('print',()=>console.log(3));
service.subscribe('print',print);
service.unSubscribe('print',print);
service.emit('print',1,2);
//1 2
//2
//3
```

## 实现异步任务队列

**描述**：请实现异步任务队列类，该类可以指定能够同时的处理异步任务数量n，同一时间最多只能有n个异步任务在执行，其他的异步任务存储在队列中，当一个异步任务执行完成后，若队列中还有未执行的任务，则自动将其执行。

**分析**：为方便理解，这里举一个例子，假设当前最多可以同时执行2个异步任务，那么有如下4个异步任务依次进入队列中: 任务4：耗时4秒，打印4、任务2：耗时2秒，打印2、任务1：耗时1秒，打印1、任务3：耗时3秒，打印3。如果没有最多同时执行任务数量限制的话，会依次输出1、2、3、4。但是，在最多同时执行两个异步任务的情况下，流程为：

- 0秒时：任务4进入队列并开始执行，任务2进入队列并开始执行，任务1进入队列等待、任务3进入队列等待

- 2秒时：任务2执行完毕打印2，从队列中推出任务1开始执行

- 3秒时：任务1执行完毕打印1，从队列中推出任务3开始执行

- 4秒时：任务4执行完毕打印4

- 6秒时：任务3执行完毕打印3

所以在允许两个异步同时执行的限制下，输出结果为：2、1、4、3。同理在允许三个异步任务同时执行的限制下，输出结果为：1、2、4、3。

**实现**：

```javascript
//实现异步任务队列
class AsyncQueue{
  constructor(n){
    this.n=n; //同时执行的异步任务的最大数量
    this.queue=[];
    this.cur=0;
  }

  addTask(task){
    return new Promise((res,rej)=>{
      if(this.cur<this.n){
        this.runTask({res,rej,task});
      }else{
        this.queue.push({res,rej,task});
      }
    })
  }

  runTask({res,rej,task}){
    this.cur++;
    return Promise.resolve(task()).then(v=>{
      this.cur--;
      res(v);
      if(this.queue.length>0){
        this.runTask(this.queue.shift());
      }
    }).catch(err => rej(err))
  }
}

let asyncQueue =new AsyncQueue(2);

function genPromise(v,delay,flag){
  return ()=>{
    return new Promise((res,rej)=>{
      setTimeout(()=>{
        flag?res(v):rej(v);
      },delay)
    })
  }
}

asyncQueue.addTask(genPromise(4,4000,true)).then(v => console.log(v));
asyncQueue.addTask(genPromise(2,2000,true)).then(v => console.log(v));
asyncQueue.addTask(genPromise(1,1000,true)).then(v => console.log(v));
asyncQueue.addTask(genPromise(3,3000,true)).then(v => console.log(v));
//2
//1
//4
//3
```

## 数组扁平化

**描述**：给你一个数组arr以及其深度n，返回该数组扁平化后的结果。注意，只有嵌套层级大于n的数组才会被执行扁平化

**分析**：题解来自leetcode。由于这是一个深度嵌套结构，解决方法中将涉及一些重复步骤，因此递归是解决此问题的合适方法。

**实现**：leetcode题解

```javascript
const flat=(arr,n) => {
  let res = [];
  const flatting = (nums,l) => {
    for(let num of nums){
      if(Array.isArray(num) && l>0){
        flatting(num,l-1);
      }else{
        res.push(num);
      }
    }
  }
  flatting(arr,n);
  return res;
}
```

## 记忆函数

**描述**：请你编写一个函数 `fn`，它接收另一个函数作为输入，并返回该函数的记忆化后的结果。记忆函数是一个对于相同的输入永远不会被调用两次的函数。相反，它将返回一个缓存值。假设被要求记忆的函数为fn(a,b){return a+b}。a，b为整数。

**分析**：记忆函数在很多地方都有应用。比如React.memo、缓存网站文件、API调用缓存等。要实现可以在本地建立一个缓存存放参数与结果的键值对，每次调用先检查是否存储过参数(key)，如果缓存中有，则直接取值，如果没有再经过函数计算。

**实现**：

```javascript
function memoize(fn) {
    const cache=new Map();
    return function(...args) {
        let key=args.join('|');
        if(cache.has(key)){
            return cache.get(key);
        }else{
            let res=fn(...args);
            cache.set(key,res);
            return res;
        }
    }
}
```

## 有效括号判断

**描述**：请你判断一个只由’(‘, ')', '[', ']', '{', '}'这六种字符组成的括号字符串是否有效。有效括号字符串指的是：1.左括号必须用相同类型的右括号闭合；2.左括号必须以正确的顺序闭合；3.每个右括号都有一个对应的相同类型的左括号。

**分析**：可以考虑使用栈数据结构来解决。 依次将每个字符入栈，当入栈的右括号与栈顶的左括号匹配时，则让栈顶的左右括号出栈。当入栈的右括号与栈顶的左括号不匹配或者遍历完字符串后栈不为空，说明字符串不为有效括号字符串。

**实现**：

```javascript
const isValid = (str) => {
    const stack = [];
    const dic = {};
    dic[')'] = '(';
    dic[']'] = '[';
    dic['}'] = '{';
    for(let c of str){
        if(c === '('  || c === '['  || c === '{'){
            stack.push(c);
        }else{
            if(dic[c] === stack[stack.length-1]){
                stack.pop();
            }else{
                return false
            }
        }
    }
    return stack.length === 0 
}
```

## 括号生成

**描述**：给定一个整数n，请涉及一个函数，输出所有n对括号能组成的有效括号字符串。例如输入3，输出['()()()', '()(())', '(())()', '(()())', '((()))']。

**分析**：回溯算法的经典题型，可以考虑使用回溯算法。同时增加限制条件筛选一些不正确的结果。

```javascript
const generateParenthesis = (n) => {
    const result = [];
    function backtrack(str, left, right){
        if(str.length == 2*n){
            result.push(str);
            return;
        }
        if(left < n){
            backtrack(str+'(',left+1,right);
        }
        if(right < left){
            backtrack(str+')',left,right+1);
        }
    }

    backtrack('',0,0);
    return result;
}
```

## 版本号排序

**描述**：给一个版本号数组，请根据版本号来排序。例：输入['0.1.1', '2.3.3', '0.302.1', '4.2', '4.3.5', '4.3.4.5'];输出['0.1.1', '0.302.1', '2.3.3', '4.3.4.5', '4.3.5']

**分析**：将版本号分组，按组来进行比较

**实现**：

```javascript
function sortVersion(arr){
  return arr.sort((v1,v2)=>{
    let verArr1 = v1.split('.');
    let verArr2 = v2.split('.');
    let maxLength = Math.max(verArr1.length,verArr2.length);
    for(let i=0;i<maxLength;i++){
      let v1Part = + verArr1[i] || 0;
      let v2Part = + verArr2[i] || 0;
      if(v1Part != v2Part){
        return v1Part-v2Part;
      }
    }
    return 0;
  })
}
```

## 金额格式化

**描述**：给定一个数字，请返回其格式字符串。例如：输入1234567 ；输出’1,234,567‘.

**分析**：先将数字转为字符串，再每三个中间插入一个',' 。注意负数以及小数

**实现**：

```javascript
function transformMoney(number){
  //是否为负数的标识
  let flag = false;

  if(number<0){
    flag = true;
    number = -number;
  }

  let moneyStr = number+'';
  let [leftStr,rightStr = ''] = moneyStr.split('.');
  let leftStrArr = leftStr.split('').reverse();
  let leftStrArrNew = [];
  for(let i=0;i<leftStrArr.length;i++){
    leftStrArrNew.push(leftStrArr[i]);
    if(i>0 && (i!=leftStrArr.length-1) && (i%3===2)){
      leftStrArrNew.push(',');
    }
  }

  let rightStrArr = rightStr.split('');
  let rightStrArrNew = [];
  for(let i=0;i<rightStrArr.length;i++){
    rightStrArrNew.push(rightStrArr[i]);
    if(i>0 && i!=rightStrArr.length-1 && i%3===2){
      rightStrArrNew.push(',');
    }
  }
  let leftResult = flag ? '-'+leftStrArrNew.reverse().join('') :leftStrArrNew.reverse().join('');
  let rightResult = rightStrArrNew.length === 0 ? '':'.'+rightStrArrNew.join('');

  return leftResult+rightResult;
}

console.log(transformMoney(-1234567.12345))
//-1,234,567.123,45
```

## 实现一个React的useState Hook

**描述**：请实现一个React的useState hook

**分析**：useState的输入是一个可选的初始值，输出为一个数组，数组第一个元素为当前状态，该值是会变化的，第二个元素为改变当前状态的函数，既可以输入一个新值，也可以输入一个函数。

**实现**：

```javascript
const useState = defaultValue => {
    const value = useRef(defaultValue);
    
    const setValue = newValue => {
        if (typeof newValue === 'function') {
            value.current = newValue(value.current);
        } else {
            value.current = newValue;
        }
    }
    
    //  触发组件的重新渲染
    dispatchAction();
    
    return [value.current, setValue];
}

```
