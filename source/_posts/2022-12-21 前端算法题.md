---
title: 前端算法题
date: 2022-12-21 10:03:23
updated: 2024-05-05 09:11:10
categories: 算法
tags: [算法]
---
# 前端算法题

## 前言

既然要写一个前端技术博客，一些前端的算法题当然要记录下来。这里的题很多都是我在面试过程中遇到过的，也有一些是四处收集来的，相较与leetcode上的代码题。这里的算法题更加注重前端方向，也是对前端er代码能力的重要考验。当然题目的解法大部分还是自己想的，也有小部分收集到的，如果有哪里不对，还请大家帮忙指正。

## 实现Promise.all

**描述**：请自己实现一个Promise.all函数

**分析**：Promise.all函数：`const p=Promise.all([p1,p2,p3])`，参数为一个Promise数组，若非数组会报错，返回值为Promise。当p1、p2、p3都落定到fulfilled状态时，p为fulfilled状态，参数为p1、p2、p3返回值组成的数组。当数组中有一个Promise（假设为p1）落定到rejected状态时，p为rejected状态，reason为p1的reason。

**实现**：

```javascript
//实现Promise.all

const myPromiseAll=(promises)=>{
  if(!(promises instanceof Array)){
    throw new Error('not array');
  }
  if(promises.length===0){
    return Promise.resolve([]);
  }

  const res=[];
  let length= promises.length;

  return new Promise((resolve,reject)=>{
    promises.forEach((p,i) => {
      Promise.resolve(p).then(v => {
        res[i]=v;
        length--;
        if(length===0){
          resolve(res);
        }
      }).catch(err => {
        reject(err);
      })
    })
  })

}

const genPromise = (v,flag,delay)=> {
  return new Promise((res,rej)=>{
    setTimeout(()=>{
      flag?res(v):rej(v);
    },delay)
  })
}

const testData=[genPromise(1,true,1000),genPromise(2,false,2000),genPromise(3,true,3000)];

myPromiseAll(testData)
.then(v=>console.log(v)).catch(err => console.log(err));

Promise.all(testData)
.then(v=>console.log(v)).catch(err => console.log(err));
```

## 实现Promise.allSettled

**描述**：请自己实现一个Promise.allSettled函数

**分析**：Promise.all函数：`const p=Promise.all([p1,p2,p3])`，参数为一个Promise数组，若非数组会报错，返回值为Promise。当p1、p2、p3都落定到fulfilled状态时，p为fulfilled状态，参数为p1、p2、p3返回值组成的数组。当数组中有一个Promise（假设为p1）落定到rejected状态时，p为rejected状态，reason为p1的reason。

**实现**：

```javascript
//实现Promise.allSettled

const myPromiseAllSettled=(promises)=>{
  if(!(promises instanceof Array)){
    throw new Error('not array');
  }
  if(promises.length===0){
    return Promise.resolve([]);
  }

  const res=[];
  let length= promises.length;

  return new Promise((resolve,reject)=>{
    promises.forEach((p,i) => {
      Promise.resolve(p).then(v => {
        res[i]={
          status:'fulfilled',
          value:v
        };

      }).catch(err => {
        res[i]={
          status:'rejected',
          reason:err
        }
      }).finally(()=>{
        length--;
        if(length===0){
          resolve(res);
        }
      })
    })
  })

}

const genPromise = (v,flag,delay)=> {
  return new Promise((res,rej)=>{
    setTimeout(()=>{
      flag?res(v):rej(v);
    },delay)
  })
}

const testData=[genPromise(1,true,1000),genPromise(2,false,2000),genPromise(3,true,3000)];

myPromiseAllSettled(testData)
.then(v=>console.log(v)).catch(err => console.log(err));

Promise.allSettled(testData)
.then(v=>console.log(v)).catch(err => console.log(err));
```

## 实现async函数

**描述**：请自己实现async函数，即使用同步的写法来书写异步函数。

**分析**：async函数最重要的特点是，在函数内部，遇到await关键字时会中断函数的执行，直到其后的异步函数返回结果，函数才能继续执行。考虑到中断函数执行，很自然可以想到Generator也可以中断函数执行，执行Generator函数会生成一个迭代器。通过调用迭代器的next函数可以手动恢复函数执行直到遇到下一个yield关键字。如果将yield关键字视作await关键字，那么还需要解决的问题有两个，1是需要在异步函数执行完毕后自动恢复函数执行，2是需要将异步函数返回的值保存下来以供后续代码的使用。

**实现**：

```javascript
// 实现async函数

function *genAsyncFunc(){
  const v1 = yield genPromise(1,true,1000);
  console.log(v1);

  const v2 = yield genPromise(2,true,1000);
  console.log(v1+v2);

  const v3 = yield genPromise(3,true,1000);
  console.log(v1+v2+v3);
}

//装饰器，模拟async关键字的作用
function asyncFunc(fn){
  let iter = fn();

  const addNext = ({value,done})=>{
    if(!done){
      Promise.resolve(value).then(v => {
        addNext(iter.next(v))
      }).catch(err => {throw err});
    }
  }

  addNext(iter.next());
}

const genPromise = (v,flag,delay)=> {
  return new Promise((res,rej)=>{
    setTimeout(()=>{
      flag?res(v):rej(v);
    },delay)
  })
}

asyncFunc(genAsyncFunc);
```

## 实现节流函数

**描述**：节流是为了避免某个函数被频繁的调用而采取的控制手段，一个函数使用节流封装后，可以实现在指定时间内，函数被调用若干次也只执行一次的效果。

**分析**：根据描述，可以知道节流函数的输入有两个，分别是被封装的函数，以及指定时间。返回一个使用节流封装后的函数。需要注意的点有，节流函数在第一次被调用时应该立即执行，指定时间内的第二次或更多次调用应当延时到指定时间之后执行。

**实现**：

```javascript
//节流
function throttle(fn,delay){
  let timer = null;
  let oldDate = Date.now();
  return function(){
    let curDate = Date.now();
    let remainTime = delay - (curDate - oldDate);
    let context = this;
    let arg = arguments;
    clearTimeout(timer);
    if(remainTime < 0){
      fn.apply(context,arg);
      oldDate = curDate;
    }else{
      timer = setTimeout(()=>fn.apply(context,arg),remainTime);
    }
  }
}

let printFn = throttle((v)=>console.log(v),1000);

setTimeout(()=>{
  printFn(1);
  printFn(2);
  printFn(3);
  //1
  //3
  //这里连续调用了printFn三次，1被立即输出，2和3都在延迟时间内所以2被忽略，而3被推迟到延迟时间之后执行。
},2000);

setTimeout(()=>printFn(4),4000);
```

## 实现防抖函数

**描述**：防抖也是为了避免某些函数被频繁调用而设计的，它的效果是函数被调用后，不立刻执行，而是等待delay秒后再执行，这期间如果被再次调用，那么以最后一次调用时间开始重新等待delay秒后执行。即一个函数被连续一连串的调用后，实际只执行一次，执行的时机是最后一次调用的时间+delay后的时刻。

**分析**：和节流一样，防抖函数的输入也有两个，一个是被封装的函数，另一个是延迟时间。返回一个使用防抖包装后的函数。

**实现**：

```javascript
//实现防抖函数
//简单的防抖函数，第一次调用时不立即执行
function denounce(fn,delay){
  let timer = null;
  return function(){
    const context = this;
    const arg = arguments;
    if(timer){
      clearTimeout(timer);
    }
    timer = setTimeout(()=>{
      fn.apply(context,arg);
      timer = null;
    },delay);
  }
}

//稍微复杂一点的防抖，第一次调用的时候立即执行，后续调用延迟执行
function denounce1(fn,delay,immediate){
  let timer = null;
  return function(){
    const context = this;
    const arg = arguments;
    if(timer){
      clearTimeout(timer);
    }
    if(immediate){
      //第一次调用的时候立即执行
      if(!timer){
        //timer内什么都不做，只是为了下一次函数调用时让函数知道已经不是第一次调用了
        timer = setTimeout(()=>timer = null,delay);  
        fn.apply(context,arg);
      }else{
        timer = setTimeout(()=>{
          fn.apply(context,arg);
          timer = null;
        },delay);
      }
    }else{
      timer = setTimeout(()=>{
        fn.apply(context,arg);
        timer = null;
      },delay);
    }
  }
}

let printValue = denounce((v)=>console.log(v),1000);
printValue(1);
printValue(2);
printValue(3);
//3
setTimeout(()=>{
  printValue = denounce1((v)=>console.log(v),1000,true);
  printValue(1);
  printValue(2);
  printValue(3);
  //1
  //3
},2000);
```

## 实现发布订阅模式

**描述**：请自己实现发布订阅模式。

**分析**：发布订阅模式，即用户可以订阅某个事件，并注册回调函数，当事件触发后，会调用所有注册的回调函数。

**实现**：

```javascript
//实现发布订阅模式
class Service {
  constructor(){
    this.eventMap = new Map();
  }

  subscribe(event,callback){
    if(this.eventMap.has(event)){
      this.eventMap.set(event,[...this.eventMap.get(event),callback]);
    }else{
      this.eventMap.set(event,[callback]);
    }
  }

  unSubscribe(event,callback){
    let index = this.eventMap.get(event).indexOf(callback);
    if(index>=0){
      this.eventMap.get(event).splice(index,1);
    }
  }

  emit(event,...arg){
    if(this.eventMap.has(event)){
      this.eventMap.get(event).forEach(cb => cb(...arg))
    }
  }
}

const service = new Service();

let print = () =>console.log(4)
service.subscribe('print',(...arg)=>console.log(...arg));
service.subscribe('print',()=>console.log(2));
service.subscribe('print',()=>console.log(3));
service.subscribe('print',print);
service.unSubscribe('print',print);
service.emit('print',1,2);
//1 2
//2
//3
```

## 实现异步任务队列

**描述**：请实现异步任务队列类，该类可以指定能够同时的处理异步任务数量n，同一时间最多只能有n个异步任务在执行，其他的异步任务存储在队列中，当一个异步任务执行完成后，若队列中还有未执行的任务，则自动将其执行。

**分析**：为方便理解，这里举一个例子，假设当前最多可以同时执行2个异步任务，那么有如下4个异步任务依次进入队列中: 任务4：耗时4秒，打印4、任务2：耗时2秒，打印2、任务1：耗时1秒，打印1、任务3：耗时3秒，打印3。如果没有最多同时执行任务数量限制的话，会依次输出1、2、3、4。但是，在最多同时执行两个异步任务的情况下，流程为：

- 0秒时：任务4进入队列并开始执行，任务2进入队列并开始执行，任务1进入队列等待、任务3进入队列等待

- 2秒时：任务2执行完毕打印2，从队列中推出任务1开始执行

- 3秒时：任务1执行完毕打印1，从队列中推出任务3开始执行

- 4秒时：任务4执行完毕打印4

- 6秒时：任务3执行完毕打印3

所以在允许两个异步同时执行的限制下，输出结果为：2、1、4、3。同理在允许三个异步任务同时执行的限制下，输出结果为：1、2、4、3。

**实现**：

```javascript
//实现异步任务队列
class AsyncQueue{
  constructor(n){
    this.n=n; //同时执行的异步任务的最大数量
    this.queue=[];
    this.cur=0;
  }

  addTask(task){
    return new Promise((res,rej)=>{
      if(this.cur<this.n){
        this.runTask({res,rej,task});
      }else{
        this.queue.push({res,rej,task});
      }
    })
  }

  runTask({res,rej,task}){
    this.cur++;
    return Promise.resolve(task()).then(v=>{
      this.cur--;
      res(v);
      if(this.queue.length>0){
        this.runTask(this.queue.shift());
      }
    }).catch(err => rej(err))
  }
}

let asyncQueue =new AsyncQueue(2);

function genPromise(v,delay,flag){
  return ()=>{
    return new Promise((res,rej)=>{
      setTimeout(()=>{
        flag?res(v):rej(v);
      },delay)
    })
  }
}

asyncQueue.addTask(genPromise(4,4000,true)).then(v => console.log(v));
asyncQueue.addTask(genPromise(2,2000,true)).then(v => console.log(v));
asyncQueue.addTask(genPromise(1,1000,true)).then(v => console.log(v));
asyncQueue.addTask(genPromise(3,3000,true)).then(v => console.log(v));
//2
//1
//4
//3
```
